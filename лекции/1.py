"""
Лекция №6 по курсу "Искусство программирования на пайтон".
Лектор - Добряк Павел Вадимович.
Для свободного распространения среди студентов ИРИТ-РтФ.
В Интернете в открытом доступе не публиковать!

Тема: ФУНКЦИОНАЛЬНОЕ ПРОГРАММИРОВАНИЕ

Всю лекцию будем решать одну задачу:
Задача: вводится n, посчитать 1!+2!+3!+...+5!,
где n!=1*2*3*...*n

Распишем, что мы хотим посчитать:
1+1*2 + 1*2*3 + 1*2*3*4 + 1*2*3*4*5
Оптимально работающая программа будет состоять из цикла
и двух рекуррентных формул - накопителя произведения
и накопителя суммы.
"""
'''def fac(n):
    if n == 0:
        return 1 
    if n == 1:
        return 1
    return fac(n-1)* n

print(fac(4))'''


"""
s=0
p=1
n=int(input())
for i in range(1,n+1):
    p=p*i
    s=s+p
print(s)
"""
"""
Эта версия - пример структурной парадигмы программирования.

Напишем программу в процедурной парадигме.
Естественным образом задача декомпозируется в две функции.
Сперва напишем функцию вычисления факториала,
потом функцию вычисления суммы факториалов:
"""
"""
def fact(n):
    r=1
    for i in range(1,n+1):
        r=r*i
    return r

def sumfact(n):
    s=0
    for i in range(1,n+1):
        s=s+fact(i)
    return s

print(sumfact(5))
"""
"""
Процедурная версия выглядит проще, чем структурная,
но она медленнее, так как в структурной версии у нас один цикл,
а в процедурной, фактически, цикл внутри цикла.
То есть 1*2*3*4*5 вычисляется полностью заново,
хотя на предыдущем этапе мы уже посчитали 1*2*3*4
Для оценки быстродействия алгоритмов используется O-нотация.
Структурная версия - O(n)
Процедурная версия - O(n^2)
Подробнее об оценках алгоритма будет рассказано при изучении
дисциплины "Алгоритмы и структуры данных".
Процедурную версию можно ускорить, применяя кеш:
"""
"""
F={}
def fact(n):
    if n not in F:
        r=1
        for i in range(1,n+1):
            r=r*i
        F[n]=r
    return F[n]

def sumfact(n):
    s=0
    for i in range(1,n+1):
        s=s+fact(i)
    return s

print(sumfact(5))
"""
"""
Вернемся к процедурной версии без кеша.
Один из смыслов написания функции - это универсальность использования.
Почему мы считаем именно сумму факториалов?
Давайте напишем функцию сигма, которая будет считать:
f(1)+f(2)+f(3)+...+f(n)
Где f - любая функция от двух аргументов.
Если подумать, а какие аргументы будут у sigma, то это будут n и f.
"""
"""
def fact(n):
    r=1
    for i in range(1,n+1):
        r=r*i
    return r

def sigma(n,f):
    s=0
    for i in range(1,n+1):
        s=s+f(i)
    return s

print(sigma(5,fact))
"""
"""
С этой версии начинается функциональная парадигма программирования.
Заметим, что до сих пор наши функции в качестве аргумента принимали
числа, строки, списки, множества, словари.
Теперь функции принимают в качестве аргумента другие функции.
Такие функции называются функциями высшего порядка
(в математике ещё используется термин "функционал").
С этой программы мы погрузимся в чарующий мир функционального
программирования, в котором функции обрабатывают другие функции,
и даже порождают другие функции и многое другое.

Обратите внимание, как факториал передается в сигму:
sigma(5,fact)
факториал здесь без круглых скобок, здесь мы его не вызываем,
а передаем его как объект - по имени.

Раз мы написали функцию сигма, то напишем и функцию пи,
которая будет считать:
f(1)*f(2)*f(3)*...*f(n)
А факториал будет "оберткой" над этой функцией, то есть вызывать её.
Но для факториала в пи, по аналогии с сигмой, надо передавать
какую-то функцию. Подумаем, что это за функция:
pi=f(1)*f(2)*f(3)*...*f(n)
n!=  1 *  2 *  3 *...*  n
Получается, что f(i) -> i.
Напишем функцию simple, которая это делает.
"""
"""
def pi(n,f):
    r=1
    for i in range(1,n+1):
        r=r*f(i)
    return r

def simple(n):
    return n

def fact(n):
    return pi(n,simple)

def sigma(n,f):
    s=0
    for i in range(1,n+1):
        s=s+f(i)
    return s

print(sigma(5,fact))
"""
"""
Если сравнить функции сигма и пи, то увидим, что их код очень похож.
А это верный признак того, что их надо объединить.
Напишем универсальную функцию ряда:
R=f(1)of(2)of(3)o...of(n),
где кружком o обозначена любая бинарная операция.
У функции row появляется ещё один аргумент - функция,
реализующая бинарную операцию (для нашей задачи - сложение summ и
умножение mult).
Также код сигма и пи различается начальным значением накопителя (0 и 1),
поэтому тоже поместим его в аргументы функции ряда.
"""
"""
def simple(n):
    return n

def mult(x,y):
    return x*y

def summ(x,y):
    return x+y

def fact(n):
    return row(n,simple,1,mult)

def row(n,f,s,b):
    for i in range(1,n+1):
        s=b(s,f(i))
    return s

print(row(5,fact,0,summ))
"""
"""
Возникает вопрос о целесообразности написания универсальной функции ряда.
Есть паттерны проектирования - часто встречающиеся ситуации в "жизни программиста",
Для них описаны типовые решения.
А есть антипаттерны - часто встречающиеся ситуации, где программисты
делают архитектурные ошибки.
Таким антипаттерном является "божественная функция" - попытка написать
функцию, которая будет делать что-угодно.
Не является ли наша универсальная функция ряда такой "божественной функцией"?
Думаю, что нет. Если вы посмотрите на ряды Тейлора для тригонометрических
функций, то увидите, что при небольших изменениях нашу функцию ряда можно
заставить считать множество рядов.

Но наш код теперь "выглядит как-то не по питоновски".
Слишком много строк кода.
Пришлось написать три дополнительные функции - simple, mult и sum.
Для функций есть вторая форма записи помимо def -
с помощью ключевого слова lambda:
"""
"""
simple = lambda n : n
mult = lambda x,y : x*y
summ = lambda x,y : x+y

def fact(n):
    return row(n,simple,1,mult)

def row(n,f,s,b):
    for i in range(1,n+1):
        s=b(s,f(i))
    return s

print(row(5,fact,0,summ))
"""
"""
Обратите внимание, что в lambda нет return.
Но lambda - это не просто более короткая запись.
С помощью этого оператора мы отделяем имя функции от её реализации.
А это означает, что мы можем использовать код с лямбдой, вообще не задавая
имя функции в том месте, где он нужен!
Избавимся от simple, sum и mult, перенеся код туда, где он нужен:
"""
"""
def fact(n):
    return row(n,lambda n : n,1,lambda x,y : x*y)

def row(n,f,s,b):
    for i in range(1,n+1):
        s=b(s,f(i))
    return s

print(row(5,fact,0,lambda x,y : x+y))
"""
"""
Итак, lambda - это анонимная функция - основа функционального программирования,
на которой строится множество приемов этой парадигмы.
В основе функционального программирования лежит строгая математика
(лямбда-исчисление), в котором оператор лямбда - это способ комбинирования
функций.

Мы можем преобразовать функцию факториал также с помощью лямбды:
"""
"""
fact = lambda n : row(n,lambda n : n,1,lambda x,y : x*y)

def row(n,f,s,b):
    for i in range(1,n+1):
        s=b(s,f(i))
    return s

print(row(5,fact,0,lambda x,y : x+y))
"""
"""
Теперь избавимся от имени fact, поместив его код в вызов row.
Мы получим программу в функциональном стиле.
"""
"""
def row(n,f,s,b):
    for i in range(1,n+1):
        s=b(s,f(i))
    return s

print(row(5,lambda n : row(n,lambda n : n,1,lambda x,y : x*y),
          0,lambda x,y : x+y))
"""
"""
Если мы сравним версии в структурном стиле и процедурном стиле с
функциональной версией, то возникает вопрос: "А это вообще Питон?!"
Здесь мы "на своей шкуре почувствовали", что такое
разные парадигмы программирования.
В питоне программы можно писать очень по-разному.

И то, что мы написали, ещё не совсем функциональная парадигма.
Чтобы написать чистую функциональную версию, надо ещё избавится от цикла
(циклы можно заменить на рекурсию).

Последнюю версию суммы факториалов я уже написал "из любви к искусству".
Это как высокая мода: полюбоваться можно, а носить нельзя.
Так писать не стоит, таким кодом вы напугаете своих коллег.
Но этот пример важен тем,
что демонстрирует логику применения функций высших порядков и анонимных функций.
В питоне есть множество встроенных функций высших порядков,
которые применяются программистами в реальном практическом программировании.
Рассмотрим некоторые из них.

Для двух маленьких задач далее напишем три версии:
структурную, декларативную (питоновские однострочники) и функциональную.

Задача №1. Отобрать положительные элементы списка.
Структурный стиль:
"""
"""
L=[0,1,-2,3,-4,5,-6]
print(L)
M=[]
for n in L:
    if n>0:
        M.append(n)
print(M)
"""
"""
Декларативный стиль (питоновские однострочники):
"""
"""
L=[0,1,-2,3,-4,5,-6]
print(L)
M=[n for n in L if n>0]      
print(M)
"""
"""
Для фильтрации списка используем встроенный функционал filter
"""
"""
def positive(n):
    if n>0:
        return True
    else:
        return False

L=[0,1,-2,3,-4,5,-6]
print(L)
M=list(filter(positive,L))
print(M)
"""
"""
Функцию, определяющую, положительное число n или нет, можно написать проще:
"""
"""
def positive(n):
    return n>0

L=[0,1,-2,3,-4,5,-6]
print(L)
M=list(filter(positive,L))
print(M)
"""
"""
Заменим эту функцию на анонимную:
"""
"""
L=[0,1,-2,3,-4,5,-6]
print(L)
M=list(filter(lambda n : n>0 ,L))
print(M)
"""
"""
Задача №2 Для заданного списка сформировать список квадратов.

Структурный стиль:
"""
"""
L=[0,1,-2,3,-4,5,-6]
M=[]
for n in L:
    M.append(n**2)
print(M)
"""
"""
Декларативный стиль (питоновские однострочники):
"""
"""
L=[0,1,-2,3,-4,5,-6]
M=[n**2 for n in L]
print(M)
"""
"""
Для отображения списка в новый используем функционал map:
"""
"""
L=[0,1,-2,3,-4,5,-6]
M=list(map(lambda n : n**2,L))
print(M)
"""
"""
Задача №3. Для списка найти произведение его элементов.


К сложению элементов коллекции с помощью sum(L) мы уже привыкли.
Что делать, если надо посчитать произведение элементов списка?
Отдельного функционала для умножения нет, но есть функционал reduce,
который стягивает коллекцию в одно число с помощью бинарной операции:
"""
"""
from functools import reduce

L=[10,30,20]
print(sum(L))
print(reduce(lambda x,y : x*y,L))
"""
"""
Обратите внимание, что reduce находится в библиотеке functools,
которая содержит много полезного для функционального программирования.
Мы уже имели дело с декоратором @cache из этой библиотеки.
"""
"""
Задача 4. Отсортировать составную коллекцию.

Привычные нам sorted, min и max содержат скрытые аргументы по умолчанию.
Они, на самом деле, являются функциями высшего порядка.
В следующем примере элементы списка - это кортежи из двух элементов.
Мы можем отсортировать список и найти максимум по нулевому или первому элементу:
"""
"""
L=[(3,10),
   (2,5),
   (1,20)]
print(L)
print(sorted(L))
print(sorted(L, key = lambda el : el[1]))
print(max(L))
print(max(L, key = lambda el : el[1]))
"""

"""
Вернемся теперь к задаче вычисления суммы факториалов и, на этот раз,
воспользуемся встроенными питоновскими средствами:
1) Составим список 1,2,3,...,n для этого воспользуемся range
2) стянем список в одно число 1*2*3*...*n c помощью reduce
и получим функцию вычисления факториала.
3) Вновь создадим список 1,2,3,...,n с помощью range
4) Отобразим список в 1!,2!,3!,...,n! с помощью map
5) Посчитаем сумму 1!+2!+3!+...+n! c помощью sum

Функция факториала:
"""
"""
from functools import reduce

def fact(n):
    L=list(range(1,n+1))
    return (reduce(lambda x,y : x*y,L))

print(fact(5))
"""
"""
Функции-обертки над операциями типа lambda x,y : x*y - это типовые ситуации,
и в питоне для них есть библиотека operator, которая содержит анонимные функции
над арифметическими, побитовыми операциями и операциями сравнения, логики.
"""
"""
from functools import reduce
from operator import mul

def fact(n):
    L=list(range(1,n+1))
    return reduce(mul, L)

print(fact(5))
"""
"""
Сумма факториалов:
"""
"""
from functools import reduce
from operator import mul

def fact(n):
    L=list(range(1,n+1))
    return reduce(mul, L)

n=5
L=list(range(1,n+1))
M=list(map(fact,L))
print(M)
print(sum(M))
"""
"""
Избавимся от лишних переменных
(обратите внимание, что list можно не писать):
"""
"""
from functools import reduce
from operator import mul

def fact(n):
    return reduce(mul, range(1,n+1))

n=5
print(sum(map(fact,range(1,n+1))))
"""
"""
Запишем факториал в виде лямбды:
"""
"""
from functools import reduce

fact = lambda n: reduce(mul,range(1,n+1))

n=5
print(sum(map(fact,range(1,n+1))))
"""
"""
Сделаем факториал анонимной функцией:
"""
"""
from functools import reduce
from operator import mul

n=5
print(sum(map(lambda n : reduce(mul, range(1,n+1)),range(1,n+1))))
"""
"""
Используя функции высших порядков, анонимные функции и встроенные в питон функционалы,
мы лишь заглянули в мир приемов функционального программирования.
Про следующие приемы: захват переменных, частичное применение функции, карринг, ленивые вычисления -
лучше рассказывать в рамках других парадигм, "выросших" из функционального программирования или
активно использующих его возможности. И к такой парадигме - аспектно-ориентированному программированию -
мы перейдем на следующей лекции.
"""








'''
сапер 
100 мин, 10 бонусов через random
поле 1000*1000

реализовать поле в форматах 
1) список списков 
2) храним занятые клетки в словаре 

замерить время выполнения каждой и сравнить check_cell(x, y)

t1 = time.time()
t2 = time.time()
diff = t1- t2'''

import random
import time

width,height = 1000, 1000
mines = 100
bonus = 10 
total = mines+ bonus

def create_list():
    field = [[0 for _ in range(width)] for _ in range(height)]
    coords= random.sample([(x,y) for x in range(width) for y in range(height)], total)
    for x, y in coords[:mines]:
        field[x][y] = "M"
    for x, y in coords[:bonus]:
        field[x][y] = "B"
    return field

def check(a, b):
    t1 =time.time()
    a()
    t2 = time.time()
    b()
    t3 = time.time()
    return (t2-t1) - (t3-t2)

def create_dict():
    cells = {}
    coords= random.sample([(x,y) for x in range(width) for y in range(height)], total)
    for x, y in coords[:mines]:
        cells[(x, y)] = "M"
    for x, y in coords[:bonus]:
        cells[(x, y)] = "B"
    return cells


print(check(create_list,create_dict))



